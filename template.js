
var fs = require('fs')
var solc = require('solc')
var $properties, base
var utils = {
    makeNamedObject: function (name, toName) {
        var obj = {}
        obj[name] = toName
        return obj
    },

    customizeType: function (obj) {
        var internal = ""
        switch (obj.type) {            
            case "bool":
                obj["x-contractType"] = obj.type
                obj.type = "boolean"                
            break;
            default:
                obj["x-contractType"] = obj.type
                obj.type = "string"
            break;
        }
        return obj
    },

    consumeInput: function(input){
        var output = {}
        if (input.type === "file") {
            output.subtype = "file"
            output.location = input.location
            output.type = "string"
            input = input.content
        } else {
            output.type = "string"
        }
        try {
            var stats = fs.statSync(input)
            if (stats.isFile()) {
                var contents = fs.readFileSync(input, "utf8")
                output.location = input
                output.content = contents
                output.type = "file"
                return this.consumeInput(output)
            }
        } catch(err){
            try { input = JSON.parse(input)} catch(err){}
            var isArray = Array.isArray(input)
            if (isArray && input[0].type !== undefined && input[0].name !== undefined ) {
                output.content = input
                output.type = "interface"
                return output
            } else {
                var compiledOutput = solc.compile(input, 1); // 1 activates the optimiser
                if (!compiledOutput.errors) {
                    output.content = compiledOutput
                    output.type = "contract"
                    return output
                }
            }
            output.content = input
            return output
        } 
    }
}
module.exports = {
    utils: utils,

    //Compile from abi
    compileFromAbi: function($abi, $name, $bytecode){
        var isArray = Array.isArray($abi)
        if (!isArray) throw "Object provided should be an array (abi compile)"
        var functions = $abi.filter(function(item){return item.type === "function"})
        var events = $abi.filter(function(item){return item.type === "event"})
        var paths =  this.pathsTemplate("get",functions, $name).paths
        if ($bytecode && $name) {
            paths["/"+$name+"/deploy"] = this.pathTemplate("post",this.deployTemplate($name), $name, $bytecode)["/"+$name+"/deploy"]
        }
        var definitions = this.definitionsTemplate(events).definitions
        return this.generateBase(paths, definitions, "1.0.0", $name)
    },

    compileFromSol: function(){},

    //deploy
    deployTemplate: function ($name) {
        return {
                "constant": true,
                "inputs": [],
                "name": "deploy",
                "outputs": [
                    {
                        "name": "address",
                        "type": "address"
                    }
                ],
                "type": "function"
            }
    },

    //Base
    generateBase: function ($paths, $definitions, $version, $name) {
        var versionPath = "/v"
        if ($version) { versionPath += $version.split('.')[0] } else { versionPath += "1" }
        return base =
            {
                "paths": $paths || {},
                "definitions": $definitions || {},
                "swagger": "2.0",
                "info": {
                    "version": $version || "1.0.0" ,
                    "title": $name || "Generated API (sol2swagger)" ,
                    "description": "Swagger API generated by sol2swagger",
                    "contact": {
                        "name": "Shannon Code",
                        "email": "shannon@loyyal.com",
                        "url": "http://loyyal.com"
                    }
                },
                "schemes": ["http", "https"],
                "host": "localhost:8545",
                "basePath": versionPath,
                "consumes": ["application/json"],
                "produces": ["application/json"]
            }
    },

    //Property collection
    propertiesTemplate: function ($properties) {
        var isArray = Array.isArray($properties)
        if (!isArray) throw "Object provided should be an array (properties)"
        if (isArray) {
            var properties = {}
            Object.keys($properties).forEach(function(key) {
                properties[$properties[key].name] = module.exports.propertyTemplate($properties[key])
            })
        }
        return {"properties": properties}
    },

    //Property
    propertyTemplate: function ($property) {
        var isArray = Array.isArray($property)
        if ($property.type === undefined || 
        isArray || Object.keys($property).length > 3 ) throw "Object provided is not a property"
        return  utils.customizeType({
            "type": $property.type
        })
    },

    //Single Definition
    definitionTemplate: function ($operation) {
        //console.log($operation.inputs)
        var isArray = Array.isArray($operation)
        if (isArray) throw "Object provided should be an object (definition)"
        return  this.propertiesTemplate($operation.inputs)
    },

    //Definition collection
    definitionsTemplate: function ($operations) {
        //console.log($operations)
        var isArray = Array.isArray($operations)
        if (!isArray) throw "Object provided should be an array (definitions)"
        var definitions = {}
        Object.keys($operations).forEach(function(key) {
            var nameAdjust = ""
            if ($operations[key].type === "event") {nameAdjust = "Event"}
            definitions[$operations[key].name + nameAdjust] = module.exports.definitionTemplate($operations[key])
            //console.log(module.exports.definitionTemplate($operations[key]))
        })
        return {"definitions": definitions}
    },

    //Response object
    responseTemplate: function ($response) {
        return {
            "200": {
                "description": "200 ok",
                "schema": this.propertiesTemplate($response)
            }
        }

    },
    //Request parameter
    parameterTemplate: function ($parameter) {
        return utils.customizeType(
        {
            "name": $parameter.name,
            "type": $parameter.type,
            "required": true,
            "in": "query",
            "default": "",
            "description": "",
        })
    },

    //Request parameters
    parametersTemplate: function ($parameters) {
        var parameterTemplate = this.parameterTemplate
        var isArray = Array.isArray($parameters)
        if (isArray && $parameters.length < 1) return []
        if (!isArray && $parameters.type === undefined) throw "Provided object is not a parameter"

        if (isArray) {
            var baseObject = []
            $parameters.forEach(function (parameter, index, array) {
                baseObject.push(parameterTemplate(parameter))
            })
            return baseObject
        } else {
            return parameterTemplate(parameters)
        }
    },

    //Operation
    operationTemplate: function ($summary, $operation, $name, $bytecode) {
        var tag = []
        if ($name !== undefined) {tag = [$name]}
        var obj = {
            "tags": tag,
            "summary": $summary,
            "parameters": this.parametersTemplate($operation.inputs),
            "responses": this.responseTemplate($operation.outputs),
            "deprecated": false,
        }
        if ($bytecode) {
            obj["description"] = "deploys the following bytecode " + $bytecode
        }

        return obj
    },

    //Endpoint
    pathTemplate: function ($verb, $operation, $name, $bytecode) {
        if ($operation.type !== "function") throw "Operation provided is not a function"
        var path = "/"
        if ($name) {
            path += $name + "/"
        }
        return utils.makeNamedObject(
            path + $operation.name,
            utils.makeNamedObject(
                $verb,
                this.operationTemplate($verb + " " + $operation.name, $operation, $name, $bytecode)
            )
        )
    },

    //Endpoint collection
    pathsTemplate: function ($verb, $operations, $name) {
        var isArray = Array.isArray($operations)
        var pathTemplate = this.pathTemplate
        if (isArray) {
            var baseObject = {}
            Object.keys($operations).forEach(function(key) {
                var generated = module.exports.pathTemplate($verb, $operations[key], $name)
                for (var prop in generated) {
                    if (generated.hasOwnProperty(prop)) {
                        baseObject[prop] = generated[prop]
                    }
                }
            })
            return {"paths": baseObject}
        } else {
            return {"paths": this.pathTemplate($verb, $operations)}
        }
    }
}